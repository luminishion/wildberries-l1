### Какой самый эффективный способ конкатенации строк?
> strings.Builer  
> bytes.Buffer



### Что такое интерфейсы, как они применяются в Go?
> это списки сигнатур функций, которые некие типы должны реализовывать  
> применяются как инструмент для совместимости, удобства и чистоты кода


### Чем отличаются RWMutex от Mutex?
> у rwmutex есть rlock позволяющий в некоторых ситуациях читать данные из разных потоков одновременно, блокируя лишь в случае записи



### Чем отличаются буферизированные и не буферизированные каналы?
> буферизованные не блокируют при записи пока буфер не полон, при чтении пока буфер не пуст



### Какой размер у структуры struct{}{}?
> unsafe.sizeof говорит 0



### Есть ли в Go перегрузка методов или операторов?
> нет, но можно накостылить через generics, interface{}, vararg



### В какой последовательности будут выведены элементы map[int]int?
```
Пример:
m[0]=1
m[1]=124
m[2]=281
```
> в случайной



### В чем разница make и new?
- make создает слайсы, каналы, мапы. new что угодно
- new возвращает указатель
- make инициализирует память



### Сколько существует способов задать переменную типа slice или map?
- m := make([]string, 1)
- m := []string{}
- var m []string
- p := new([]string)


### Что выведет данная программа и почему?
```go
func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}
```
> 1 1  
> потому что нужно было написать *p = b



### Что выведет данная программа и почему?
```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```
> deadlock  
> потому что передается копия wg



### Что выведет данная программа и почему?
```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```
> 0  
> n в другой области видимости заного инициализировался



### Что выведет данная программа и почему?
```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```
> 100 2 3 4 5  
> нужно было ретурнить слайс из someAction



### Что выведет данная программа и почему?
```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```
> [bba][aa]  
> потому что аргументы функции перекрыли область видимости
